//////////////////////////////////////////////////////////////////////////////////////////////
// DO NOT MODIFY THIS FILE                                                                  //
// This file is automatically generated by ZenStack CLI and should not be manually updated. //
//////////////////////////////////////////////////////////////////////////////////////////////

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

generator docs {
  provider = "node node_modules/prisma-docs-generator"
  output   = "../docs/prisma"
}

generator erd {
  provider                  = "prisma-erd-generator"
  output                    = "../resources/diagrams/erd/prisma-schema.svg"
  theme                     = "default"
  includeRelationFromFields = true
}

generator erd_simple {
  provider  = "prisma-erd-generator"
  output    = "../resources/diagrams/erd/prisma-schema.simple.svg"
  theme     = "default"
  tableOnly = true
}

enum ConceptType {
  person
  place
  thing
}

enum ConceptStatus {
  CREATED
  TRAINING
  TRAINED
}

enum LRScheduler {
  linear
  cosine
  cosine_with_restarts
  polynomial
  constant
  constant_with_warmup
}

enum FileResourceType {
  ckpt
  image
  model
  pdf
  safetensor
  video
}

enum FilePrivacy {
  public  @map("public-read")
  private
}

enum CloudFileRegion {
  USEast1 @map("us-east-1")
}

enum PageStatus {
  DRAFT
  PUBLISHED
}

enum PageType {
  FrontCover
  Body
  BackCover
}

enum PageTextType {
  machine_generated
  machine_translated
  user_creative_work
  user_translated
}

enum Locale {
  en_US
  en
}

/// @@deny('read', deletedAt != null)
model User {
  /// @length(1, 160)
  name      String
  /// @email
  /// @length(3, 160)
  email     String    @unique()
  artist    Artist?
  author    Author?
  editions  Edition[]
  id        String    @id() @default(cuid())
  createdAt DateTime  @default(now()) @map(name: "created_at")
  updatedAt DateTime  @updatedAt() @map(name: "updated_at")
  deletedAt DateTime? @map(name: "deleted_at")

  zenstack_guard       Boolean @default(true)
  zenstack_transaction String?

  @@index([zenstack_transaction])
  @@map("users")
}

/// @@deny('read', deletedAt != null)
model Author {
  stories   Story[]
  pageTexts PageText[]
  user      User       @relation(fields: [userId], references: [id])
  userId    String     @unique()
  id        String     @id() @default(cuid())
  createdAt DateTime   @default(now()) @map(name: "created_at")
  updatedAt DateTime   @updatedAt() @map(name: "updated_at")
  deletedAt DateTime?  @map(name: "deleted_at")
}

/// @@deny('read', deletedAt != null)
model Artist {
  stories      Story[]
  pageArtworks PageArtwork[]
  user         User          @relation(fields: [userId], references: [id])
  userId       String        @unique()
  id           String        @id() @default(cuid())
  createdAt    DateTime      @default(now()) @map(name: "created_at")
  updatedAt    DateTime      @updatedAt() @map(name: "updated_at")
  deletedAt    DateTime?     @map(name: "deleted_at")
}

/// @@deny('read', deletedAt != null)
model Translator {
  pageTexts PageText[]
  id        String     @id() @default(cuid())
  createdAt DateTime   @default(now()) @map(name: "created_at")
  updatedAt DateTime   @updatedAt() @map(name: "updated_at")
  deletedAt DateTime?  @map(name: "deleted_at")
}

/// @@deny('read', deletedAt != null)
model Concept {
  /// @length(1, 100)
  name                 String
  type                 ConceptType
  status               ConceptStatus       @default(CREATED)
  description          String?
  prompt               String
  identifier           String
  classNoun            String              @map("class_noun")
  negativePrompt       String              @map("negative_prompt")
  /// The prompt you use to describe your training images, in the format: `a [identifier] [class noun]`, where the `[identifier]` should be a rare token. Relatively short sequences with 1-3 letters work the best (e.g. `sks`, `xjy`). `[class noun]` is a coarse class descriptor of the subject (e.g. cat, dog, watch, etc.). For example, your `instance_prompt` can be `a sks dog`, or with some extra description `a photo of a sks dog`. The trained model will learn to bind a unique identifier with your specific subject in the `instance_data`.
  instancePrompt       String              @map("instance_prompt")
  /// The prompt or description of the coarse class of your training images, in the format of `a [class noun]`, optionally with some extra description. `class_prompt` is used to alleviate overfitting to your customized images (the trained model should still keep the learnt prior so that it can still generate different dogs when the `[identifier]` is not in the prompt). Corresponding to the examples of the `instant_prompt` above, the `class_prompt` can be `a dog` or `a photo of a dog`.
  classPrompt          String              @map("class_prompt")
  positivePrompts      String[]            @map("positive_prompts")
  negativePrompts      String[]            @map("negative_prompts")
  dreamboothTrainingId String?             @map("dreambooth_training_id")
  dreamboothTraining   DreamBoothTraining? @relation(fields: [dreamboothTrainingId], references: [id])
  /// @url
  dreamboothModelURI   String?             @map("dreambooth_model_uri")
  photos               Photo[]
  id                   String              @id() @default(cuid())
  createdAt            DateTime            @default(now()) @map(name: "created_at")
  updatedAt            DateTime            @updatedAt() @map(name: "updated_at")
  deletedAt            DateTime?           @map(name: "deleted_at")

  zenstack_guard       Boolean @default(true)
  zenstack_transaction String?

  @@index([zenstack_transaction])
  @@map("concepts")
}

model Prediction {
  id           String    @id() @default(cuid())
  uuid         String    @unique()
  input        Json?
  output       Json?
  status       String?
  created_at   DateTime?
  started_at   DateTime?
  completed_at DateTime?
  version      String?
  metrics      Json?
  error        String?
  logs         String?   @db.Text()

  @@map(name: "predictions")
}

/// There are a few inputs you should know about when training with this model:
///
/// - `instance_data`   (required) - A ZIP file containing your training images (JPG, PNG, etc. size not restricted). These images contain your "subject" that you want the trained model to embed in the output domain for later generating customized scenes beyond the training images. For best results, use images without noise or unrelated object in the background.
/// - `instance_prompt` (required) - This is the prompt you use to describe your training images, in the format: `a [identifier] [class noun]`, where the `[identifier]` should be a rare-token - it is found that relatively short sequences with 1-3 letters work the best (e.g. `sks`, `xjy`). `[class noun]` is a coarse class descriptor of the subject (e.g. cat, dog, watch, etc.). For example, your `instance_prompt` can be: `a sks dog`, or with some extra description `a photo of a xjy dog`. The trained model will learn to bind a unique identifier with your specific subject in the `instance_data`.
/// - `class_prompt`    (required) - This is the prompt or description of the coarse class of your training images, in the format of `a [class noun]` (or with some extra description).  `class_prompt` is used to alleviate overfitting to your customized images (the trained model should still keep the learnt prior so that it can still generate different dogs when the `[identifier]` is not in the prompt). Corresponding to the examples of the `instant_prompt` above, the `class_prompt` can be `a dog` or `a photo of a dog`.
/// - `class_data`      (optional) - This corresponds to `class_prompt` above, also with the purpose to keep the generalizability of the model. By default, the pretrained stable-diffusion model will generate N (determined by the `num_class_images` you set) images based on the `class_prompt` provided above. But to save time or to to have your preferred specific set of `class_data`, you can also provide them in a ZIP file.
///
/// You may also want to change `num_class_images` and the `max_train_steps` settings, to trade-off speed and quality.
///
/// `seed` is randomly initialized to 1337, feel free to change it!
///
model DreamBoothTraining {
  id                          String      @id() @default(cuid())
  createdAt                   DateTime    @default(now()) @map("created_at")
  /// The prompt you use to describe your training images, in the format: `a [identifier] [class noun]`, where the `[identifier]` should be a rare token. Relatively short sequences with 1-3 letters work the best (e.g. `sks`, `xjy`). `[class noun]` is a coarse class descriptor of the subject (e.g. cat, dog, watch, etc.). For example, your `instance_prompt` can be `a sks dog`, or with some extra description `a photo of a sks dog`. The trained model will learn to bind a unique identifier with your specific subject in the `instance_data`.
  instance_prompt             String
  /// The prompt or description of the coarse class of your training images, in the format of `a [class noun]`, optionally with some extra description. `class_prompt` is used to alleviate overfitting to your customized images (the trained model should still keep the learnt prior so that it can still generate different dogs when the `[identifier]` is not in the prompt). Corresponding to the examples of the `instant_prompt` above, the `class_prompt` can be `a dog` or `a photo of a dog`.
  class_prompt                String
  /// A ZIP file containing your training images (JPG, PNG, etc. size not restricted). These images contain your 'subject' that you want the trained model to embed in the output domain for later generating customized scenes beyond the training images. For best results, use images without noise or unrelated objects in the background.
  instance_data               String
  /// An optional ZIP file containing the training data of class images. This corresponds to `class_prompt` above, also with the purpose of keeping the model generalizable. By default, the pretrained stable-diffusion model will generate N images (determined by the `num_class_images` you set) based on the `class_prompt` provided. But to save time or to have your preferred specific set of `class_data`, you can also provide them in a ZIP file.
  class_data                  String
  /// Minimal class images for prior preservation loss. If not enough images are provided in class_data, additional images will be sampled with class_prompt.
  num_class_images            Int         @default(50)
  /// The prompt used to generate sample outputs to save.
  save_sample_prompt          String?
  /// The negative prompt used to generate sample outputs to save.
  save_sample_negative_prompt String?
  /// The number of samples to save.
  n_save_sample               Int         @default(4)
  /// CFG for save sample.
  save_guidance_scale         Float       @default(7.5)
  /// The number of inference steps for save sample.
  save_infer_steps            Int         @default(50)
  /// Flag to pad tokens to length 77.
  pad_tokens                  Boolean     @default(false)
  /// Flag to add prior preservation loss.
  with_prior_preservation     Boolean     @default(true)
  /// Weight of prior preservation loss.
  prior_loss_weight           Float       @default(1)
  /// A seed for reproducible training
  seed                        Int         @default(1337)
  /// The resolution for input images. All the images in the train/validation dataset will be resized to this resolution.
  resolution                  Int         @default(512)
  /// Whether to center crop images before resizing to resolution
  center_crop                 Boolean     @default(false)
  /// Whether to train the text encoder
  train_text_encoder          Boolean     @default(true)
  /// Batch size (per device) for the training dataloader.
  train_batch_size            Int         @default(1)
  /// Batch size (per device) for sampling images.
  sample_batch_size           Int         @default(4)
  /// Number of training epochs
  num_train_epochs            Int         @default(1)
  /// Total number of training steps to perform.  If provided, overrides num_train_epochs.
  max_train_steps             Int         @default(2000)
  /// Number of updates steps to accumulate before performing a backward/update pass.
  gradient_accumulation_steps Int         @default(1)
  /// Whether or not to use gradient checkpointing to save memory at the expense of slower backward pass.
  gradient_checkpointing      Boolean     @default(false)
  /// Initial learning rate (after the potential warmup period) to use.
  learning_rate               Float       @default(0.000001)
  /// Scale the learning rate by the number of GPUs, gradient accumulation steps, and batch size.
  scale_lr                    Boolean     @default(false)
  /// The scheduler type to use
  lr_scheduler                LRScheduler @default(constant)
  /// Number of steps for the warmup in the lr scheduler.
  lr_warmup_steps             Int         @default(0)
  /// Whether or not to use 8-bit Adam from bitsandbytes.
  use_8bit_adam               Boolean     @default(false)
  /// The beta1 parameter for the Adam optimizer.
  adam_beta1                  Float       @default(0.9)
  /// The beta2 parameter for the Adam optimizer.
  adam_beta2                  Float       @default(0.999)
  /// Weight decay to use
  adam_weight_decay           Float       @default(0.01)
  /// Epsilon value for the Adam optimizer
  /// Max gradient norm.
  max_grad_norm               Float       @default(1)
  Concept                     Concept[]
}

/// @@deny('read', deletedAt != null)
model Edition {
  userId    String    @unique() @map("user_id")
  /// @zod.string.cuid()
  pdfId     String    @unique() @map("pdf_id")
  /// @zod.string.cuid()
  user      User      @relation(fields: [userId], references: [id])
  pdf       PDF       @relation(fields: [pdfId], references: [id])
  id        String    @id() @default(cuid())
  createdAt DateTime  @default(now()) @map(name: "created_at")
  updatedAt DateTime  @updatedAt() @map(name: "updated_at")
  deletedAt DateTime? @map(name: "deleted_at")

  @@index([userId], name: "Edition_userId")
  @@map("editions")
}

/// @@deny('read', deletedAt != null)
model CloudFile {
  /// File name
  filename     String
  /// Filename without extension
  stem         String
  /// @length(1, 7)
  /// File extension
  extension    String
  /// @gt(0)
  /// Filesize in bytes
  size         Int
  /// File MIME type
  mime         String
  /// Generic version of MIME
  resourceType FileResourceType @map("resource_type")
  /// Consolidated embedded metadata associated with the file. It includes exif, iptc, and xmp data.
  /// @zod.custom.use(z.record(z.union([z.string(), z.number()])))
  metadata     Json?
  key          String
  /// S3 Key
  bucket       String
  /// S3 Bucket
  region       CloudFileRegion
  publicUrl    String?          @unique()
  /// @zod.string.url()
  privacy      FilePrivacy      @default(private)
  /// Privacy on blob store
  photo        Photo?
  pdf          PDF?
  id           String           @id() @default(cuid())
  createdAt    DateTime         @default(now()) @map(name: "created_at")
  updatedAt    DateTime         @updatedAt() @map(name: "updated_at")
  deletedAt    DateTime?        @map(name: "deleted_at")

  zenstack_guard       Boolean @default(true)
  zenstack_transaction String?

  @@unique([region, bucket, key])
  @@index([zenstack_transaction])
  @@map("cloud_files")
}

/// @@deny('read', deletedAt != null)
model Photo {
  /// @gt(0)
  height       Int           @db.SmallInt()
  /// @gt(0)
  width        Int           @db.SmallInt()
  tags         String[]      @default([])
  fileId       String        @unique() @map("file_id")
  /// @zod.string.cuid()
  file         CloudFile     @relation(fields: [fileId], references: [id])
  pageArtworks PageArtwork[]
  concepts     Concept[]
  id           String        @id() @default(cuid())
  createdAt    DateTime      @default(now()) @map(name: "created_at")
  updatedAt    DateTime      @updatedAt() @map(name: "updated_at")
  deletedAt    DateTime?     @map(name: "deleted_at")

  zenstack_guard       Boolean @default(true)
  zenstack_transaction String?

  @@index([zenstack_transaction])
  @@map("photos")
}

/// @@deny('read', deletedAt != null)
model PDF {
  /// @gt(0)
  height    Int       @db.SmallInt()
  /// @gt(0)
  width     Int       @db.SmallInt()
  /// @gt(0)
  pages     Int       @db.SmallInt()
  tags      String[]
  fileId    String    @unique() @map("file_id")
  /// @zod.string.cuid()
  file      CloudFile @relation(fields: [fileId], references: [id])
  edition   Edition?
  id        String    @id() @default(cuid())
  createdAt DateTime  @default(now()) @map(name: "created_at")
  updatedAt DateTime  @updatedAt() @map(name: "updated_at")
  deletedAt DateTime? @map(name: "deleted_at")

  zenstack_guard       Boolean @default(true)
  zenstack_transaction String?

  @@index([zenstack_transaction])
  @@map("pdfs")
}

/// @@deny('read', deletedAt != null)
model Story {
  artistId     String?       @map("artist_id")
  /// @zod.string.cuid()
  authorId     String?       @map("author_id")
  /// @zod.string.cuid()
  artist       Artist?       @relation(fields: [artistId], references: [id], onDelete: Cascade)
  author       Author?       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  pages        Page[]
  pageArtworks PageArtwork[]
  pageTexts    PageText[]
  id           String        @id() @default(cuid())
  createdAt    DateTime      @default(now()) @map(name: "created_at")
  updatedAt    DateTime      @updatedAt() @map(name: "updated_at")
  deletedAt    DateTime?     @map(name: "deleted_at")

  @@index([artistId], name: "Story_artistId")
  @@index([authorId], name: "Story_authorId")
  @@map("stories")
}

/// @@deny('read', deletedAt != null)
model PageArtwork {
  status    PageStatus @default(DRAFT)
  pageId    String     @map("page_id")
  /// @zod.string.cuid()
  storyId   String     @map("story_id")
  /// @zod.string.cuid()
  artistId  String     @map("artist_id")
  /// @zod.string.cuid()
  photoId   String     @map("photo_id")
  /// @zod.string.cuid()
  page      Page       @relation(fields: [pageId], references: [id], onDelete: Cascade)
  story     Story      @relation(fields: [storyId], references: [id], onDelete: Cascade)
  artist    Artist     @relation(fields: [artistId], references: [id], onDelete: Cascade)
  photo     Photo      @relation(fields: [photoId], references: [id], onDelete: Cascade)
  id        String     @id() @default(cuid())
  createdAt DateTime   @default(now()) @map(name: "created_at")
  updatedAt DateTime   @updatedAt() @map(name: "updated_at")
  deletedAt DateTime?  @map(name: "deleted_at")

  @@index([pageId], name: "PageArtwork_pageId")
  @@map("page_artworks")
}

/// @@deny('read', deletedAt != null)
model PageText {
  status       PageStatus   @default(DRAFT)
  locale       Locale
  text         String
  /// @zod.string.min(1).max(5000)
  type         PageTextType
  pageId       String       @map("page_id")
  /// @zod.string.cuid()
  storyId      String       @map("story_id")
  /// @zod.string.cuid()
  authorId     String?      @map("author_id")
  /// @zod.string.cuid()
  translatorId String?      @map("translator_id")
  /// @zod.string.cuid()
  page         Page         @relation(fields: [pageId], references: [id], onDelete: Cascade)
  story        Story        @relation(fields: [storyId], references: [id], onDelete: Cascade)
  author       Author?      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  translator   Translator?  @relation(fields: [translatorId], references: [id])
  id           String       @id() @default(cuid())
  createdAt    DateTime     @default(now()) @map(name: "created_at")
  updatedAt    DateTime     @updatedAt() @map(name: "updated_at")
  deletedAt    DateTime?    @map(name: "deleted_at")

  @@index([pageId], name: "PageText_pageId")
  @@map("page_texts")
}

/// @@deny('read', deletedAt != null)
model Page {
  status     PageStatus    @default(DRAFT)
  type       PageType
  pageNumber Int           @map("page_number") @db.SmallInt()
  /// @zod.number.gte(1).lte(100)
  storyId    String        @map("story_id")
  /// @zod.string.cuid()
  story      Story         @relation(fields: [storyId], references: [id], onDelete: Cascade)
  artworks   PageArtwork[]
  texts      PageText[]
  id         String        @id() @default(cuid())
  createdAt  DateTime      @default(now()) @map(name: "created_at")
  updatedAt  DateTime      @updatedAt() @map(name: "updated_at")
  deletedAt  DateTime?     @map(name: "deleted_at")

  @@index([storyId], name: "Page_storyId")
  @@map("pages")
}
