// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// -----------------------------------------------------------------------------
// Concepts
// -----------------------------------------------------------------------------

// enum ConceptType {
//   PERSON
//   PLACE
//   THING
// }

// model Concept {
//   id       String  @id @default(cuid())
//   userId   String?
//   familyId String?

//   type ConceptType

//   user   User?   @relation(fields: [userId], references: [id])
//   Family Family? @relation(fields: [familyId], references: [id])
// }

model FaceMesh {
  id   String @id @default(cuid())
  data Json
  User User[]

  createdAt DateTime @default(now()) @map(name: "created_at")
  updatedAt DateTime @updatedAt @map(name: "updated_at")
}

/// - `instance_data` (required) - A ZIP file containing your training images (JPG, PNG, etc. size not restricted). These images contain your "subject" that you want the trained model to embed in the output domain for later generating customized scenes beyond the training images. For best results, use images without noise or unrelated object in the background.
/// - `instance_prompt` (required) - This is the prompt you use to describe your training images, in the format: `a [identifier] [class noun]`, where the `[identifier]` should be a rare-token - it is found that relatively short sequences with 1-3 letters work the best (e.g. `sks`, `xjy`). `[class noun]` is a coarse class descriptor of the subject (e.g. cat, dog, watch, etc.). For example, your `instance_prompt` can be: `a sks dog`, or with some extra description `a photo of a xjy dog`. The trained model will learn to bind a unique identifier with your specific subject in the `instance_data`.
/// - `class_prompt` (required) - This is the prompt or description of the coarse class of your training images, in the format of `a [class noun]` (or with some extra description).  `class_prompt` is used to alleviate overfitting to your customized images (the trained model should still keep the learnt prior so that it can still generate different dogs when the `[identifier]` is not in the prompt). Corresponding to the examples of the `instant_prompt` above, the `class_prompt` can be `a dog` or `a photo of a dog`. 
/// - `class_data` (optional). This corresponds to `class_prompt` above, also with the purpose to keep the generalizability of the model. By default, the pretrained stable-diffusion model will generate N (determined by the `num_class_images` you set) images based on the `class_prompt` provided above. But to save time or to to have your preferred specific set of `class_data`, you can also provide them in a ZIP file.
///
/// You may also want to change `num_class_images` and the `max_train_steps` settings, to trade-off speed and quality.
/// `seed` is randomly initialized to 1337, feel free to change it!
model ConceptTensor {
  id             String @id @default(cuid())
  identifier     String
  classNoun      String @map(name: "class_noun")
  classPrompt    String @map(name: "class_prompt")
  instancePrompt String @map(name: "instance_prompt")
  tensorUrl      String @map(name: "tensor_url")

  prediction DreamBoothPrediction @relation(fields: [dreamBoothPredictionId], references: [id])

  createdAt              DateTime @default(now()) @map(name: "created_at")
  dreamBoothPredictionId String
}

model ConceptPerson {
  id     String @id @default(cuid())
  userId String @unique @map(name: "user_id")
  user   User   @relation(fields: [userId], references: [id])
  // concepts ConceptTensor[]

  createdAt DateTime @default(now()) @map(name: "created_at")
  updatedAt DateTime @updatedAt @map(name: "updated_at")
}

model ConceptPlace {
  id       String @id @default(cuid())
  userId   String @map(name: "user_id")
  familyId String @map(name: "family_id")
  user     User   @relation(fields: [userId], references: [id])
  Family   Family @relation(fields: [familyId], references: [id])

  createdAt DateTime @default(now()) @map(name: "created_at")
  updatedAt DateTime @updatedAt @map(name: "updated_at")
}

model ConceptThing {
  id       String @id @default(cuid())
  userId   String @map(name: "user_id")
  familyId String @map(name: "family_id")
  user     User   @relation(fields: [userId], references: [id])
  Family   Family @relation(fields: [familyId], references: [id])

  createdAt DateTime @default(now()) @map(name: "created_at")
  updatedAt DateTime @updatedAt @map(name: "updated_at")
}

// -----------------------------------------------------------------------------
// Family Genealogy
// See: https://github.com/sedelmeyer/family-genealogy-database
// -----------------------------------------------------------------------------

// enum RelationshipRole {
//   CHILD
//   PARENT
//   GRANDPARENT
//   COUSIN
//   NEPHEW
//   NIECE
// }

// model FamiliarRelationship {
//   user1 User
//   user
// }

model Family {
  id     String         @id @default(cuid())
  user   User[]
  places ConceptPlace[]
  things ConceptThing[]

  createdAt DateTime @default(now()) @map(name: "created_at")
  updatedAt DateTime @updatedAt @map(name: "updated_at")
}

enum Sex {
  MALE
  FEMALE
}

enum Gender {
  AGENDER
  ANDROGYNE
  ANDROGYNOUS
  BIGENDER
  CIS
  CISGENDER
  CIS_FEMALE
  CIS_MALE
  CIS_MAN
  CIS_WOMAN
  CISGENDER_FEMALE
  CISGENDER_MALE
  CISGENDER_MAN
  CISGENDER_WOMAN
  FEMALE_TO_MALE
  FTM
  GENDER_FLUID
  GENDER_NONCONFORMING
  GENDER_QUESTIONING
  GENDER_VARIANT
  GENDERQUEER
  INTERSEX
  MALE_TO_FEMALE
  MTF
  NEITHER
  NEUTROIS
  NON_BINARY
  OTHER
  PANGENDER
  TRANS
  // TRANS*
  TRANS_FEMALE
  // TRANS*_FEMALE
  TRANS_MALE
  // TRANS*_MALE
  TRANS_MAN
  // TRANS*_MAN
  TRANS_PERSON
  // TRANS*_PERSON
  TRANS_WOMAN
  // TRANS*_WOMAN
  TRANSFEMININE
  TRANSGENDER
  TRANSGENDER_FEMALE
  TRANSGENDER_MALE
  TRANSGENDER_MAN
  TRANSGENDER_PERSON
  TRANSGENDER_WOMAN
  TRANSMASCULINE
  TRANSSEXUAL
  TRANSSEXUAL_FEMALE
  TRANSSEXUAL_MALE
  TRANSSEXUAL_MAN
  TRANSSEXUAL_PERSON
  TRANSSEXUAL_WOMAN
  TWO_SPIRIT
}

model User {
  id                    String   @id @default(cuid())
  faceMeshId            String?  @map(name: "face_mesh_id")
  name                  String
  nickname              String?
  birthdate             DateTime
  sex                   Sex
  gender                Gender
  genderPronounSingular String   @map(name: "gender_pronoun_singular")
  genderPronounPlural   String   @map(name: "gender_pronoun_plural")

  face     FaceMesh?      @relation(fields: [faceMeshId], references: [id])
  families Family[]
  person   ConceptPerson?
  places   ConceptPlace[]
  things   ConceptThing[]

  createdAt DateTime @default(now()) @map(name: "created_at")
  updatedAt DateTime @updatedAt @map(name: "updated_at")
}

// -----------------------------------------------------------------------------
// Stories
// -----------------------------------------------------------------------------

model Story {
  id        String      @id @default(cuid())
  UserStory UserStory[]

  createdAt DateTime @default(now()) @map(name: "created_at")
  updatedAt DateTime @updatedAt @map(name: "updated_at")
}

model UserStory {
  id      String @id @default(cuid())
  storyId String @map(name: "story_id")
  story   Story  @relation(fields: [storyId], references: [id])

  createdAt DateTime @default(now()) @map(name: "created_at")
  updatedAt DateTime @updatedAt @map(name: "updated_at")
}

// -----------------------------------------------------------------------------
// Predictions
// -----------------------------------------------------------------------------

model Prediction {
  id           String    @id @default(cuid())
  input        Json?
  output       Json?
  status       String?
  created_at   DateTime?
  started_at   DateTime?
  completed_at DateTime?
  version      String?
  metrics      Json?
  error        String?
  logs         String?   @db.Text
}

// -----------------------------------------------------------------------------
// DreamBooth
// -----------------------------------------------------------------------------

enum LRScheduler {
  linear
  cosine
  cosine_with_restarts
  polynomial
  constant
  constant_with_warmup
}

/// There are a few inputs you should know about when training with this model:
/// 
/// - `instance_data`   (required) - A ZIP file containing your training images (JPG, PNG, etc. size not restricted). These images contain your "subject" that you want the trained model to embed in the output domain for later generating customized scenes beyond the training images. For best results, use images without noise or unrelated object in the background.
/// - `instance_prompt` (required) - This is the prompt you use to describe your training images, in the format: `a [identifier] [class noun]`, where the `[identifier]` should be a rare-token - it is found that relatively short sequences with 1-3 letters work the best (e.g. `sks`, `xjy`). `[class noun]` is a coarse class descriptor of the subject (e.g. cat, dog, watch, etc.). For example, your `instance_prompt` can be: `a sks dog`, or with some extra description `a photo of a xjy dog`. The trained model will learn to bind a unique identifier with your specific subject in the `instance_data`.
/// - `class_prompt`    (required) - This is the prompt or description of the coarse class of your training images, in the format of `a [class noun]` (or with some extra description).  `class_prompt` is used to alleviate overfitting to your customized images (the trained model should still keep the learnt prior so that it can still generate different dogs when the `[identifier]` is not in the prompt). Corresponding to the examples of the `instant_prompt` above, the `class_prompt` can be `a dog` or `a photo of a dog`. 
/// - `class_data`      (optional) - This corresponds to `class_prompt` above, also with the purpose to keep the generalizability of the model. By default, the pretrained stable-diffusion model will generate N (determined by the `num_class_images` you set) images based on the `class_prompt` provided above. But to save time or to to have your preferred specific set of `class_data`, you can also provide them in a ZIP file.
/// 
/// You may also want to change `num_class_images` and the `max_train_steps` settings, to trade-off speed and quality.
/// 
/// `seed` is randomly initialized to 1337, feel free to change it!
///
model DreamBoothPrediction {
  id String @id @default(cuid())

  /// The prompt you use to describe your training images, in the format: `a [identifier] [class noun]`, where the `[identifier]` should be a rare token. Relatively short sequences with 1-3 letters work the best (e.g. `sks`, `xjy`). `[class noun]` is a coarse class descriptor of the subject (e.g. cat, dog, watch, etc.). For example, your `instance_prompt` can be `a sks dog`, or with some extra description `a photo of a sks dog`. The trained model will learn to bind a unique identifier with your specific subject in the `instance_data`.
  instance_prompt String

  /// The prompt or description of the coarse class of your training images, in the format of `a [class noun]`, optionally with some extra description. `class_prompt` is used to alleviate overfitting to your customized images (the trained model should still keep the learnt prior so that it can still generate different dogs when the `[identifier]` is not in the prompt). Corresponding to the examples of the `instant_prompt` above, the `class_prompt` can be `a dog` or `a photo of a dog`.
  class_prompt String

  /// A ZIP file containing your training images (JPG, PNG, etc. size not restricted). These images contain your 'subject' that you want the trained model to embed in the output domain for later generating customized scenes beyond the training images. For best results, use images without noise or unrelated objects in the background.
  instance_data String // Path

  /// An optional ZIP file containing the training data of class images. This corresponds to `class_prompt` above, also with the purpose of keeping the model generalizable. By default, the pretrained stable-diffusion model will generate N images (determined by the `num_class_images` you set) based on the `class_prompt` provided. But to save time or to have your preferred specific set of `class_data`, you can also provide them in a ZIP file.
  class_data String // Path

  /// Minimal class images for prior preservation loss. If not enough images are provided in class_data, additional images will be sampled with class_prompt.
  num_class_images Int @default(50)

  /// The prompt used to generate sample outputs to save.
  save_sample_prompt String?

  /// The negative prompt used to generate sample outputs to save.
  save_sample_negative_prompt String?

  /// The number of samples to save.
  n_save_sample Int @default(4)

  /// CFG for save sample.
  save_guidance_scale Float @default(7.5)

  /// The number of inference steps for save sample.
  save_infer_steps Int @default(50)

  /// Flag to pad tokens to length 77.
  pad_tokens Boolean @default(false)

  /// Flag to add prior preservation loss.
  with_prior_preservation Boolean @default(true)

  /// Weight of prior preservation loss.
  prior_loss_weight Float @default(1.0)

  /// A seed for reproducible training
  seed Int @default(1337)

  /// The resolution for input images. All the images in the train/validation dataset will be resized to this resolution.
  resolution Int @default(512)

  /// Whether to center crop images before resizing to resolution
  center_crop Boolean @default(false)

  /// Whether to train the text encoder
  train_text_encoder Boolean @default(true)

  /// Batch size (per device) for the training dataloader.
  train_batch_size Int @default(1)

  /// Batch size (per device) for sampling images.
  sample_batch_size Int @default(4)

  /// Number of training epochs
  num_train_epochs Int @default(1)

  /// Total number of training steps to perform.  If provided, overrides num_train_epochs.
  max_train_steps Int @default(2000)

  /// Number of updates steps to accumulate before performing a backward/update pass.
  gradient_accumulation_steps Int @default(1)

  /// Whether or not to use gradient checkpointing to save memory at the expense of slower backward pass.
  gradient_checkpointing Boolean @default(false)

  /// Initial learning rate (after the potential warmup period) to use.
  learning_rate Float @default(0.000001)

  /// Scale the learning rate by the number of GPUs, gradient accumulation steps, and batch size.
  scale_lr Boolean @default(false)

  /// The scheduler type to use
  lr_scheduler LRScheduler @default(constant)

  /// Number of steps for the warmup in the lr scheduler.
  lr_warmup_steps Int @default(0)

  /// Whether or not to use 8-bit Adam from bitsandbytes.
  use_8bit_adam Boolean @default(false)

  /// The beta1 parameter for the Adam optimizer.
  adam_beta1 Float @default(0.9)

  /// The beta2 parameter for the Adam optimizer.
  adam_beta2 Float @default(0.999)

  /// Weight decay to use
  adam_weight_decay Float @default(0.01)

  /// Epsilon value for the Adam optimizer
  adam_epsilon Float @default(0.00000001)

  /// Max gradient norm.
  max_grad_norm Float @default(1.0)

  ConceptTensor ConceptTensor[]
}
